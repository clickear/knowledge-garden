---
date created: 2022-09-08
date modified: 2022-09-08
title: 并发带来的问题
---

> [!TIP] 技巧💡  
> 脏读重点在于事务B里面修改了数据，**尚未提交**,  
不可重复读的重点在于事务B**更新**了数据，并且已经提交。  
幻读的重点在于事务B里面**新增**了数据.  
解决脏读、不可重复读、幻读的思路:  
1.加锁，增加写写的并发  
2.[[MVCC]]多版本控制，增加读写不互相影响的并发。

## 并发带来的问题。

+ [[更新丢失]]（Lost Update）:  
+ [[脏读]]（Dirty Reads）  
+ [[不可重复读]]（Non-Repeatable Reads）  
+ [[幻读]]（Phantom Reads）  

### 幻读和不可重复读的区别：

- **不可重复读的重点是修改**：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）
- **幻读的重点在于新增或者删除**：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）

### 并发事务处理带来的问题的解决办法：

1. "[[更新丢失]]”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。
2. “脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：
	1. 一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。 •
	2. 另一种是数据多版本并发控制（MultiVersion Concurrency Control，简称 **[[MVCC]]** 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。为了解决的是**读写并发。 读读并发不用处理，写写并发，通过锁来解决**

