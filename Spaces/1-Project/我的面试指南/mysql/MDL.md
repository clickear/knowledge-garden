---
title: MDL
date created: 2023-03-01
date modified: 2023-03-01
tags: todo/continue
---

> [!INFO] MDL（**metadata lock**）  
> 1.1 当对一个表做增删改查的时候，该表会被加MDL读锁。（DML操作需要MDL读锁)  
> 1.2 当对表做结构变更的时候，加MDL写锁。(DDL操作需要MDL写锁)  
> 1.3 读读不互斥，读写，写写互斥。  
> 1.4 一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。事务一旦申请到MDL锁后，直到事务执行完才会将锁释放。可以理解为，当前的MDL写锁，如果事务未提交，会导致后续该表都不能进行操作。 --> 引申出一个问题，

MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务（显式或隐式）的时候，不可以对元数据进行写入操作。

## 引入MDL解决了什么问题？

1. 事务隔离问题，即会话A在2次查询期间，会话B对表结构做了修改，两次查询结果就会不一致(返回的结构不同)，无法满足可重复读的要求。
2. 数据复制问题，如会话A执行了多条更新语句期间，另外一个会话B做了表结构变更并且先提交，就会导致slave在重做时，先重做alter，再重做update时就会出现复制错误的现象。

## 出现的问题case

1. 在对表进行上述操作时，如果表上有活动事务（未提交或回滚），请求写入的会话会等待在Metadata lock wait 。
2. 已经有MDL写锁时，后续的读事务也会阻塞。直到MDL写锁提交。  
![](http://image.clickear.top/20230301163933.png)

case来源: [^1]

1. session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执行。  
2. 之后session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。  
3. 如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求(如sessionD)也会被session C阻塞。  
**如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session再请求的话，这个库的线程很快就会爆满**  

## 如何避免

1. 规范使用事务，及时提交事务，避免使用[[大事务]]。
2. 设置参数lock_wait_timeout为较小值，使被阻塞端主动停止。
3. DDL操作及备份操作放在业务低峰期执行。
4. 少用工具开启事务进行查询，图形化工具要及时关闭。

## 参考资料

[MDL锁导致的几个常见的 MySQL 问题分析 - 墨天轮](https://www.modb.pro/db/45669)  
[mysql45讲](https://book.clickear.top/mysql45/06%E8%AE%B2%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%EF%BC%9A%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D.html)

[^1]: [mysql45讲](https://book.clickear.top/mysql45/06%E8%AE%B2%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81%EF%BC%9A%E7%BB%99%E8%A1%A8%E5%8A%A0%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%80%8E%E4%B9%88%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E9%98%BB%E7%A2%8D.html)
