---
date created: 2022-09-26
date modified: 2022-09-26
title: 非公平锁
---

先到临界区的线程未必比后到的线程更快地获取得到锁。

## 实现思路

线程**先尝试能不能获取得到锁**，如果获取得到锁了就执行同步代码了。如果获取不到锁，那就再把这个线程放到队列呗

[[synchronized]]就属于非公平锁。

> [!TIP] 技巧💡  
>  synchronized无论处理哪种锁，都是**先尝试获取**，获取不到才升级|| 放到队列上的，所以是非公平的
- 偏向锁，如果当前线程ID与markword存储的不相等，则CAS尝试更换线程ID，CAS成功就获取得到锁了
- 轻量级锁实际上也是通过CAS来抢占锁资源（只不过多了拷贝Mark Word到Lock Record的过程），抢占成功到锁就归属给该线程了，但自旋失败一定次数后升级重量级锁
- 重量级锁通过monitor对象中的队列存储线程，但线程进入队列前，还是会先尝试获取得到锁，如果能获取不到才进入线程等待队列中
