

# 常青笔记
+ 流言蜚语，原来也可以实现一致性。
+ 实现数据副本的最终一致性时，一般而言，**直接邮寄**的方式是一定要实现的，因为不需要做一致性对比，只是通过发送更新数据或缓存重传，来修复数据的不一致，性能损耗低。在存储组件中，节点都是已知的，一般采用**反熵**修复数据副本的一致性。当集群节点是变化的，或者集群节点数比较多时，这时要采用**谣言传播**的方式，同步更新数据，实现最终一致


# 重要摘要

gossip，就像流言蜚语一样，利用一种**随机、带有传染性**的方式，将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。对你来说，掌握这个协议不仅能很好地理解这种最常用的，实现最终一致性的算法，也能在后续工作中得心应手地实现数据的最终一致性。


Gossip 的三板斧分别是：直接邮寄（Direct Mail）、反熵（Anti-entropy）和谣言传播（Rumor mongering）

## 直接邮寄
> 直接发送更新数据，当数据发送失败时，将数据缓存下来，然后重传。

接邮寄虽然实现起来比较容易，数据同步也很及时，但可能会因为缓存队列满了而丢数据。也就是说，只采用直接邮寄是无法实现最终一致性的.

## 反熵
> 反熵指的是集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性。

反熵是一种通过异步修复实现最终一致性的方法。
### 实现方式
推方式，就是将自己的所有副本数据，推给对方，修复对方副本中的熵。
拉方式，就是拉取对方的所有副本数据，修复自己副本中的熵。
推拉方式，就是同时修复自己副本和对方副本中的熵。


### 缺点
虽然反熵很实用，但是执行反熵时，相关的节点都是已知的，而且节点数量不能太多，如果是一个动态变化或节点数比较多的分布式环境（比如在 DevOps 环境中检测节点故障，并动态维护集群节点状态），这时反熵就不适用了。那么当你面临这个情况要怎样实现最终一致性呢？答案就是谣言传播

## 谣言传播
> 当一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据。



# 资料

[Gossip协议：流言蜚语，原来也可以实现一致性](https://book.clickear.top/114-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98/02%E4%B8%A8%E5%8D%8F%E8%AE%AE%E5%92%8C%E7%AE%97%E6%B3%95%E7%AF%87%20(11%E8%AE%B2)/11%E4%B8%A8Gossip%E5%8D%8F%E8%AE%AE%EF%BC%9A%E6%B5%81%E8%A8%80%E8%9C%9A%E8%AF%AD%EF%BC%8C%E5%8E%9F%E6%9D%A5%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%87%B4%E6%80%A7.html)