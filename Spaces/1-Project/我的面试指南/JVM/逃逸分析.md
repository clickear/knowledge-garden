---
date created: 2022-09-02
date modified: 2022-09-02
title: 逃逸分析
---
> [!TIP] 技巧💡  
> 当一个对象在方法中定义后，对象只在方法内部使用，则认为没有发生逃逸。当一个对象在方法中被定义后，它被外部方法引用，则认为发生逃逸，例如作为调用参数传递到其他地方中

栈上分配

> 将堆分配转为栈分配，如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配

同步策略

> 如果一个对象被发现只能从一个线程被访问到，对于这个对象的操作可以不考虑同步。 JIT编译器可以借助逃逸分析来判断同步块所使用的的锁对象，是否只能够被一个线程访问，而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候，就会**取消对这部分代码的同步**。这样就大大提高并发性和性能，这个取消同步的过程就叫同步省略，也叫锁消除

分离对象或标量替换

> 有的对象可能不需要作为一个连续的内存结构存在，也可以被访问到，那么对象的部分（或全部）可以不存储在内存。而是存储在CPU寄存器中 **标量**是指一个无法再分解的更小的数据的数据。Java中原始数据类型就是标量 可以分解的数据叫聚合量，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量 标量替换参数：-XX:EliminateAllocations，默认打开
