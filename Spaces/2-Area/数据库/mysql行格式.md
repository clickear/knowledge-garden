---
title: mysql行格式
date created: 2023-06-14
date modified: 2023-06-15
---

行格式，也就是在页中，每行的记录如何存储。  
在[[innodb]]中，行格式主要有4种。但是整体上，大同小异。  

1. 记录的额外信息这部分，是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为`3`类，分别是**变长字段长度列表**、**`NULL`值列表**和**记录头信息**
2. 记录真实的数据。

> [!TIP] todo💡  
> 当然没怎么介绍记录头信息，后续有空填坑。

为什么要这么麻烦，有4种格式呢？本质上，还是为了尽可能减少行记录占的大小，这样每页就可以存储更多的数据。  
这里处理的麻烦点，在于变长字段和NULL值处理。

| 行格式                          | 字段长度处理                                                 | 长度存储1个字节还是2个字节                                                                                                      | NULL值处理                                                                                                   | 溢出页处理                          |
|:------------------------------- |:------------------------------------------------------------ |:------------------------------------------------------------------------------------------------------------------------------- |:------------------------------------------------------------------------------------------------------------ |:----------------------------------- |
| [[REDUNDANT]]用的少了，早期使用 | 字段偏移长度偏移列表(重点，存储全部字段的偏移数据)           | 判断整个记录真实数据的占用大小，<=127就使用1个字节。粒度大，是整行记录都用1个字节或者2个字节，而不是根据某些列来                                                                          | 偏移数据的最高位，标识是否为NULL，所以真实占用字节用1个字节还是2个字节，是判断<=127,因为最高位给了NULL值表示 | 真实数据前768字节 +20字节溢出页地址 |
| [[COMPACT]]                     | 变长字段列表，会重复利用表定义，这里只存储变长的字段长度列表 | 结合表定义来决定，表定义最大1个字节，则直接用1个字节。否则真实数据<=127,则用1个字节，因为最高位用来判断，是1个字节还是2个字节。 | bitmap处理。将可能为NULL值的列表，通过Bitmap表示                                                             | 真实数据前768字节 +20字节溢出页地址 |
| [[DYNAMIC]] 默认行格式          |   和[[COMPACT]]一样                                                           |                      和[[COMPACT]]一样                                                                                                           |               只存储20字节的溢出页地址                                                                                               |                                     |
| [[COMPRESSED]] 压缩版                               |       和[[COMPACT]]一样                                                       |    和[[COMPACT]]一样                                                                                                                             |       只存储20字节的溢出页地址，并且主要是会对页边进行压缩                                                                                                        |                                     |

## [[COMPACT]]行格式

变长字段列表 + NULL值列表 + 记录头信息。

> [!TIP] 技巧💡  
>  针对变长字段，在额外信息中记录真实数据的占用字节数大小，来达到记录变长字节，而不是直接按最大字节来分配。  
>  针对NULl值列表，我们可以通过bitmap来记录，当前值是否为NULL值。很明显，我们只需要记录可能为NULL的字段来生成NULL的bitmap即可。那哪些字段是可以为NULL值的？怎么判断？当时是在表结构定义的时候就已经知道了。

### 变长字段列表

![image.png](http://image.clickear.top/20230614224937.png)

> [!TIP] varchar(M)占用的字节数怎么计算？💡  
>  首先，要明确几个概念。 varchar(M)中的M,是指M个字符。而不是字节。所以M个字符对应的字节与字符集有关。  
>  W: 即假设某个字符集最多需要W字节来表示一个字符。  
>  `utf8mb4`字符集中的`W`就是`4`  
> `utf8`字符集中`W`就是`3`  
>  `gbk`字符集中的`W`就是`2`  
> `ascii`字符集中的`W`就是`1`。  
>  M: varchar(M)中的M,即 M个字符。那么M个字符，如果都填充满，占用的字节是 M\*W  
>  L: 变长字段真实的存储字符串占用的字节数。明显 L <= W\*M

首先，现在我们知道，记录的额外信息，是紧凑的，没有额外的分隔符，那我们怎么知道，第一个字节是哪个字段的长度呢？又怎么确定，这个列是1个字节还是2个字节？这里就涉及到尽可能较少占用空间。

> [!TIP] 为什么前缀长度，最大用2个字节💡  
> 为什么长度前缀 1 或 2 个字节就够用了呢, 因为 2 个字节的话, 2^16 = 65536, 这已经**超过 mysql 行最大字节数 65535 的限制了**, 所以 1 到 2 个字节就够用了。

那如果确定1个字节还是2个字节来表示某个变长列的长度呢？这里定义了一套规则，目的了尽可能减少占用空间。

首先，强调一点，为了减少占用空间，我们要**充分利用表结构**。比如表定义已经明确该列固定长度是20了，那么我们就不用每行都去存储这个长度了。([[REDUNDANT]]就不够智能，后续说明。)

我们知道，1个字节，可以存储的大小为 2^8 = 256，可以存储数据到255。2^16 = 65536,可以存储到65535的大小。

1. 很容易想到，先看表结构，如果表结构定义即(M × W)<=255，那么直接用1个字节来存储。因为实际存储长度最大，也就是255个字节。
2. 如果表结构定义， >255呢？
	1. 粗暴的做法，是直接用2个字节。但是这个还有优化空间吗？
	2. 更精细化的，
		1. 如果实际存储L <= 127,那么我们就只定义1个字节就好
		2. 如果实际存储L >=127, 那么我们就使用2个字节。

> [!TIP] 这里为什么是判断L<=127呢?💡  
>  这是因为，我们会将第一个字节的首位来区分，是1个字节还是2个字节。 如果高位是1，就代表这个变长的长度是2个字节。 2^7=128.正好存储的极限是127.

总结下这个规则:

1. 先看表结构定义， MxW <=255.直接用1个字节来存储。
2. 表结构定义(MxW >255)，那么判断最高位是0还是1，如果是1，代表是2个字节来存储数据。

> [!TIP] 疑问💡  
> 这里还有个有意思的优化，mysql在存储变长字段长度的顺序，是逆序的，并不是按照字段的顺序。主要是为了尽可能使用到缓存。这里我不是很理解，这整个不是都加载到内存了吗？有什么区别吗？

> [!EXAMPLE] varchar(M) 能存多少个字符，为什么提示最大16383？ （utf-8mb4字符集，最大占4个字节）  
> 要求出这个M，首先不考虑其他列的情况，很明显，这里肯定能达到2个字节。按上限来计算。即M x W >255.  
> （65535 - 2 ）/4 = 16383.75.  
> 65535，是每个行的上限，  
> 这里-2，是因为varchar 的变长长度，存储2个字节。  
> 除4,是因为真实占用的字符M, 即每个字符要占用4个字节。所以最大16383个字节。  
> 当然，这里只是说明了只有1列，没有NULL值等情况。而且也不考虑内部碎片等问题。

### NULL值处理(bitmap)

空值的处理，就比较简单。直接找出可能为空的列表，通过bitmap来存储。标识每个字符是否是空值。

1. 主键列、被`NOT NULL`修饰的列都是不可以存储`NULL`值的，所以在统计的时候不会把这些列算进去。比方说表`test`的`3`个列`c1、c3、c4`都是允许存储`NULL`值的，而`c2`列是被`NOT NULL`修饰，不允许存储`NULL`值。
2. 如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列。二进制位的值为1时，代表该列的值为NULL，为0时，代表该列的值不为NULL。高位补0  
![image.png](http://image.clickear.top/20230614233055.png)

## [[REDUNDANT]]格式(已废弃)

了解了，[[COMPACT]]格式，[[REDUNDANT]]就很好理解了。首先，它也区分记录额外的信息和真实的数据2部分。  
额外信息:

+ 字段长度偏移列表
+ 真实数据  
和[[REDUNDANT]]比，很容易发现，他没有NULL值的bitmap.那他是如何处理NULL值的呢？

### 字段长度偏移列表

+ 这里是字段长度，注意这里不像[[REDUNDANT]]，不是变长。意味着它会记录该条记录(包含隐藏列)的长度信息。所以才是他有点浪费。
+ 记录的是偏移量，而不是具体的长度数据，不够直观。(怎么理解？)
	+ 第一列，长度是 20. 第二列，偏移量是30.那么第二列的长度是(30-20=10)。

### NULL值处理。 高位表示

这里，没有使用[[COMPACT]]的方式，使用bitmap来表示，而是将偏移量的最高位，来作为是否为NULL值。

### 怎么判断是1个字节还是2个字节

(通过记录实际占用的字节数来判断，如果>127,则全部字节都使用2个字节来表示长度。在header中会有个标识，来记录是1个字节还是2个字节表示长度)  
为什么是>127,就是2个字节？因为最高位给判断是否NULL的标识了

### 溢出页处理方式

保留真实数据的前768字节 + 20字节溢出页面地址

## [[DYNAMIC]](默认行格式)

和[[COMPACT]]基本一样，但是对溢出页处理方式不一样。它记录的是20字节溢出页面地址，没有保留真实数据的前768个字节数据。

[[COMPRESSED]]( [[DYNAMIC]]压缩数据版)  
和[[DYNAMIC]]没什么不同，主要在于进行了数据压缩。

## 文章

[varchar有最大长度吗 - 知乎](https://zhuanlan.zhihu.com/p/101215458)

[MySQL的varchar水真的太深了——InnoDB记录存储结构\_varchar存储结构\_砖业洋\_\_的博客-CSDN博客](https://blog.csdn.net/qq_34115899/article/details/117524328)
