---
title: è·³è·ƒè¡¨
aliases:
  - skip lists
date created: 2023-06-19
date modified: 2023-10-18
tags: [redis/æ•°æ®ç»“æ„]
---

dynamic order-preserving çš„æ•°æ®ç»“æ„ä¸­ï¼Œæœ€ç®€å•çš„å°±æ˜¯ sorted linked listï¼Œæ‰€æœ‰æ“ä½œçš„å¤æ‚åº¦å‡åœ¨  
O(n)ï¼Œæ€§èƒ½è¾ƒ B+ Tree ç›¸æ¯”é€Šè‰²è®¸å¤šï¼Œä½†å¦‚æœå°†å¤šä¸ª sorted linked list å’èµ·æ¥ï¼Œå°±å¯èƒ½æä¾›ä¸ B+ Tree ç›¸åª²ç¾çš„æ€§èƒ½  

![image.png](http://image.clickear.top/20230621141813.png)

- è¡¨å¤´ï¼ˆheadï¼‰ï¼šè´Ÿè´£ç»´æŠ¤è·³è·ƒè¡¨çš„èŠ‚ç‚¹æŒ‡é’ˆã€‚
- è·³è·ƒè¡¨èŠ‚ç‚¹ï¼šä¿å­˜ç€å…ƒç´ å€¼ï¼Œä»¥åŠå¤šä¸ªå±‚ã€‚
- å±‚ï¼šä¿å­˜ç€æŒ‡å‘å…¶ä»–å…ƒç´ çš„æŒ‡é’ˆã€‚é«˜å±‚çš„æŒ‡é’ˆè¶Šè¿‡çš„å…ƒç´ æ•°é‡å¤§äºç­‰äºä½å±‚çš„æŒ‡é’ˆï¼Œä¸ºäº†æé«˜æŸ¥æ‰¾çš„æ•ˆç‡ï¼Œç¨‹åºæ€»æ˜¯ä»é«˜å±‚å…ˆå¼€å§‹è®¿é—®ï¼Œç„¶åéšç€å…ƒç´ å€¼èŒƒå›´çš„ç¼©å°ï¼Œæ…¢æ…¢é™ä½å±‚æ¬¡ã€‚
- è¡¨å°¾ï¼šå…¨éƒ¨ç”±Â `NULL`Â ç»„æˆï¼Œè¡¨ç¤ºè·³è·ƒè¡¨çš„æœ«å°¾ã€‚
> [!TIP] æŠ€å·§ğŸ’¡  
> è·³è¡¨çš„**æœ¬è´¨**ï¼š**æ˜¯å¯¹æœ‰åºé“¾è¡¨çš„æ”¹é€ ï¼Œä¸ºå•é“¾è¡¨åŠ å¤šå±‚ç´¢å¼•ï¼Œä»¥ç©ºé—´æ¢æ—¶é—´çš„ç­–ç•¥ï¼Œè§£å†³äº†å•é“¾è¡¨ä¸­æŸ¥è¯¢é€Ÿåº¦çš„é—®é¢˜ï¼ŒåŒæ—¶ä¹Ÿèƒ½å¿«é€Ÿå®ç°èŒƒå›´æŸ¥è¯¢**ã€‚  
æ—¶é—´å¤æ‚åº¦ O(logn) ç©ºé—´å¤æ‚åº¦: O(n)

![image.png](http://image.clickear.top/20230627145118.png)

[Skip Lists - open-courses](https://zhenghe.gitbook.io/open-courses/mit-6.046/skip-lists)

## ä»£ç å®ç°ä¸è§£æ

### æ•°æ®ç»“æ„

+ SkipList ç”¨äºä¿å­˜è·³è·ƒè¡¨èŠ‚ç‚¹çš„ç›¸å…³ä¿¡æ¯ï¼Œ æ¯”å¦‚èŠ‚ç‚¹çš„æ•°é‡ï¼Œ ä»¥åŠæŒ‡å‘è¡¨å¤´èŠ‚ç‚¹å’Œè¡¨å°¾èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚
+ Node èŠ‚ç‚¹ç”¨æ¥è¡¨ç¤ºè·³è·ƒè¡¨çš„èŠ‚ç‚¹ã€‚å…¶ä¸­levelsï¼Œæ˜¯å±‚çº§ã€‚
+ Level å±‚çº§ï¼Œæ˜¯Nodeçš„ç»“æ„ï¼Œä»£è¡¨å±‚çº§ã€‚å±‚çº§æŒ‡å‘ä¸‹ä¸€ä¸ªNodeã€‚åœ¨æŸ¥è¯¢éå†çš„æ—¶å€™ï¼Œå°±æ˜¯æ ¹æ®è¿™ä¸ªè¿›è¡ŒæŸ¥æ‰¾ã€‚

```go
type Node struct {
  value  uint32
  levels []*Level // ç´¢å¼•èŠ‚ç‚¹,index=0æ˜¯åŸºç¡€é“¾è¡¨
}

type Level struct {
  next *Node
}

type SkipList struct {
  header *Node  // è¡¨å¤´èŠ‚ç‚¹
  length uint32 // åŸå§‹é“¾è¡¨çš„é•¿åº¦ï¼Œè¡¨å¤´èŠ‚ç‚¹ä¸è®¡å…¥
  height uint32 // æœ€é«˜çš„èŠ‚ç‚¹çš„å±‚æ•°
}

func NewSkipList() *SkipList {
  return &SkipList{
    header: NewNode(MaxLevel, 0),
    length: 0,
    height: 1,
  }
}

func NewNode(level, value uint32) *Node {
  node := new(Node)
  node.value = value
  node.levels = make([]*Level, level)

  for i := 0; i < len(node.levels); i++ {
    node.levels[i] = new(Level)
  }
  return node
}
```

### å¤šå°‘å±‚åˆé€‚ï¼Ÿ

è·³è·ƒè¡¨çš„éš¾ç‚¹ï¼Œåœ¨äºå±‚çº§é—®é¢˜ã€‚å³å¤šå°‘å±‚åˆé€‚ã€‚å¤ªå¤šå’Œå¤ªå°‘éƒ½ä¸å¤ªè¡Œã€‚ä¸€èˆ¬æ§åˆ¶æ¯å±‚çš„æ¦‚å¿µæ˜¯ä¸‹ä¸€å±‚çš„1/2. å¦‚:  
L1 1/2  
L2 1/4  
â€¦.  
é‚£å¦‚ä½•å®ç°å‘¢ï¼Ÿç›´æ¥ç”¨ç”¨éšæœºå‡½æ•°ã€‚åˆ¤æ–­è¿ç»­å‡ºç°1çš„æ¦‚ç‡ã€‚

```go
const p = 0.5
func (sl *SkipList) randomLevel() int {
  level := 1
  r := rand.New(rand.NewSource(time.Now().UnixNano()))
  for r.Float64() < p && level < MaxLevel {
    level++
  }
  return level
}
```

### æŸ¥æ‰¾

![image.png](http://image.clickear.top/20230629181146.png)

æŸ¥æ‰¾çš„æ—¶å€™ï¼Œä»å³ä¸Šè§’headerçš„æœ€é«˜å±‚çº§å¼€å§‹å¼€å§‹æŸ¥æ‰¾ã€‚

1. å½“å‰å±‚çº§å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŸ¥æ‰¾ï¼Œç›´è‡³ä¸‹èŠ‚ç‚¹>å¾…æŸ¥æ‰¾çš„å€¼ï¼Œæˆ–è€…å·²ç»æ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹ã€‚
2. å½“å‰èŠ‚ç‚¹>å¾…æŸ¥æ‰¾çš„å€¼æ—¶ï¼Œè¿›è¡Œåˆ°ä¸‹ä¸€ä¸ªå±‚çº§ã€‚

```go
func (sl *SkipList) Find(value uint32) *Node {
  tmp := sl.header
  // ä»é«˜å¾€ä½å±‚éå†æŸ¥è¯¢
  for i := int(sl.height); i > 0; i-- {
    // å½“å‰å±‚ï¼Œå‘å³æŸ¥æ‰¾ã€‚ è¿™é‡Œkeyç”¨<=ï¼Œä¸»è¦æ˜¯ä¸åé¢çš„æ’å…¥æ–¹æ³•ç›¸åŒé€»è¾‘
    for tmp.levels[i].next != nil && tmp.levels[i].next.value < value {
      tmp = tmp.levels[i].next
    }
    if tmp.levels[i].next != nil && tmp.levels[i].next.value == value {
      return tmp
    }
  }

  return nil
}
```

### æ’å…¥

![image.png](http://image.clickear.top/20230629181253.png)

æ’å…¥çš„é€»è¾‘å’ŒæŸ¥æ‰¾æ˜¯ç±»ä¼¼çš„ï¼Œæ‰¾åˆ°éœ€è¦æ’å…¥çš„åœ°æ–¹ã€‚ç„¶åå°†å¾…æ’å…¥ä½ç½®èŠ‚ç‚¹çš„å€¼ä¸´æ—¶è®°å½•åˆ°updateæ•°ç»„ä¸­ã€‚

1. ä¿å­˜éœ€è¦å¾…æ’å…¥çš„ä½ç½®ï¼Œå¹¶è®°å½•åˆ°update[i]ä¸­
2. ç”Ÿæˆå±‚çº§ï¼Œåˆ›å»ºèŠ‚ç‚¹å€¼
3. èŠ‚ç‚¹çš„æ‰€æœ‰å±‚çº§çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘ update[i].nextã€‚
4. åŸæ¥çš„èŠ‚ç‚¹çš„nextï¼Œæ›´æ–°ä¸ºå½“å‰èŠ‚ç‚¹ã€‚
5. ç‰¹æ®Šå¤„ç†ï¼Œå±‚çº§å˜é«˜çš„æƒ…å†µã€‚

```go
func (sl *SkipList) Insert(value uint32) (result bool) {
  result = false
  update := make([]*Level, MaxLevel)

  tmp := sl.header
  for i := int(sl.height); i > 0; i-- {
    // å½“å‰å±‚ï¼Œå‘å³æŸ¥æ‰¾
    for tmp.levels[i].next != nil && tmp.levels[i].next.value < value {
      tmp = tmp.levels[i].next
    }
    // ä¸æ”¯æŒé‡å¤
    if tmp.levels[i].next.value == value {
      return
    }

    update[i] = tmp.levels[i]
  }

  newLevel := sl.randomLevel()
  node := NewNode(uint32(newLevel), 0)

  for i := 0; i < newLevel; i++ {
    // è¯´æ˜æ–°èŠ‚ç‚¹å±‚æ•°è¶…è¿‡äº†è·³è¡¨å½“å‰çš„æœ€é«˜å±‚æ•°ï¼Œæ­¤æ—¶å°†å¤´èŠ‚ç‚¹å¯¹åº”å±‚æ•°çš„åç»§èŠ‚ç‚¹è®¾ç½®ä¸ºæ–°èŠ‚ç‚¹
    if update[i].next == nil {
      sl.height++
      sl.header.levels[i].next = node
      continue
    }

    node.levels[i].next = update[i].next
    update[i].next = node
  }

  sl.length++
  result = true
  return
}
```

### åˆ é™¤

åˆ é™¤ï¼Œå’Œæ’å…¥çš„é€†å‘æ“ä½œã€‚æ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹å’Œä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„ä¿¡æ¯ã€‚ç„¶åè¿›è¡Œé€†æ“ä½œã€‚å¦‚æœå±‚çº§é™ä½äº†ï¼Œè¿˜è¦å‡ä½å±‚çº§

```go
funcÂ (slÂ *SkipList)Â Delete(valueÂ uint32)Â boolÂ {  
Â Â varÂ nodeÂ *Node  
Â Â lastÂ :=Â make([]*Node,Â sl.height)  
Â Â tmpÂ :=Â sl.header  
Â Â forÂ iÂ :=Â int(sl.height)Â -Â 1;Â iÂ >=Â 0;Â i--Â {  
  
Â Â Â Â forÂ tmp.levels[i].nextÂ !=Â nilÂ &&Â tmp.levels[i].next.valueÂ <Â valueÂ {  
Â Â Â Â Â Â tmpÂ =Â tmp.levels[i].next  
Â Â Â Â }  
  
Â Â Â Â last[i]Â =Â tmp  
Â Â Â Â //Â æ‹¿åˆ°Â valueÂ å¯¹åº”çš„Â node  
Â Â Â Â ifÂ tmp.levels[i].next!=nil&&tmp.levels[i].next.valueÂ ==Â valueÂ {  
Â Â Â Â Â Â nodeÂ =Â tmp.levels[i].next  
Â Â Â Â }  
Â Â }  
  
Â Â Â Â //Â æ²¡æœ‰æ‰¾åˆ°Â valueÂ å¯¹åº”çš„Â node  
Â Â ifÂ nodeÂ ==Â nilÂ {  
Â Â Â Â returnÂ false  
Â Â }  
  
Â Â //Â æ‰¾åˆ°æ‰€æœ‰å‰ç½®èŠ‚ç‚¹åéœ€è¦åˆ é™¤node  
Â Â forÂ iÂ :=Â 0;Â iÂ <Â len(node.levels);Â i++Â {  
Â Â Â Â last[i].levels[i].nextÂ =Â node.levels[i].next  
Â Â Â Â node.levels[i].nextÂ =Â nil  
Â Â }  
  
Â Â //Â é‡å®šå‘è·³è¡¨é«˜åº¦  
Â Â forÂ iÂ :=Â 0;Â iÂ <Â len(sl.header.levels);Â i++Â {  
Â Â Â Â ifÂ sl.header.levels[i].nextÂ ==Â nilÂ {  
Â Â Â Â Â Â sl.heightÂ =Â uint32(i)  
Â Â Â Â Â Â break  
Â Â Â Â }  
Â Â }  
  
Â Â sl.length--  
  
Â Â returnÂ true  
}
```

## å¼€æºæºç åº”ç”¨

### [[redis]] [[zset]]

[Redis ä¸ºä»€ä¹ˆè¿™ä¹ˆå¿«ï¼Ÿ Redis çš„æœ‰åºé›†åˆ zset çš„åº•å±‚å®ç°åŸç†æ˜¯ä»€ä¹ˆï¼Ÿ â€”â€” è·³è·ƒè¡¨ skiplist\_51CTOåšå®¢\_redisçš„æœ‰åºé›†åˆåº•å±‚å®ç°](https://blog.51cto.com/universsky/5370131)

> [!TIP] æŠ€å·§ğŸ’¡  
>  redisä¸­ï¼Œè·³è¡¨åªåœ¨zsetç»“æ„æœ‰ä½¿ç”¨ã€‚  
> + å½“æ•°æ®è¾ƒå°‘çš„æ—¶å€™ï¼Œzsetæ˜¯ç”±ä¸€ä¸ª[[ziplist]]æ¥å®ç°çš„  
> + å½“æ•°æ®è¾ƒå¤šçš„æ—¶å€™ï¼Œzsetæ˜¯ä¸€ä¸ªç”±dict å’Œä¸€ä¸ª skiplistæ¥å®ç°çš„ï¼Œdictç”¨æ¥æŸ¥è¯¢æ•°æ®åˆ°åˆ†æ•°çš„å¯¹åº”å…³ç³»ï¼Œè€Œskiplistç”¨æ¥æ ¹æ®åˆ†æ•°æŸ¥è¯¢æ•°æ®ã€‚

![image.png](http://image.clickear.top/20230629195848.png)

```c++
struct zset{
  // è·³è·ƒè¡¨
  zskiplit *zsl;

  // å­—å…¸, å­˜å‚¨çš„keyæ˜¯ æ•°æ®ï¼Œvalueæ˜¯score
  dict *dice;
};

 struct zskiplistNode {
    // çœŸå®æ•°æ®æŒ‡é’ˆï¼Œå­˜æ”¾èŠ‚ç‚¹æ•°æ®ï¼Œå­˜æ”¾string robj
    robj *obj;
    // èŠ‚ç‚¹çš„åˆ†æ•°
    double score;
    // ä¸Šä¸€ä¸ªèŠ‚ç‚¹ï¼Œå‘å‰ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆï¼ŒèŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå‘å‰æŒ‡é’ˆï¼Œæœ€åº•å±‚æ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨
    zskiplistNode *backward;
    // å±‚çº§,å­˜æ”¾å„å±‚é“¾è¡¨çš„å‘åæŒ‡é’ˆç»“æ„
    zskiplistLevel level[];
}
// åŒ…å«ä¸€ä¸ªforward ï¼ŒæŒ‡å‘å¯¹åº”å±‚åä¸€ä¸ªèŠ‚ç‚¹
struct zskiplistLevel{
    // ä¸‹ä¸€ä¸ªæŒ‡é’ˆ
    zskiplistNode *forward;
    // è·¨åº¦ï¼Œç”¨äºæ’åç”¨
    unsinged int span;
}

struct zskiplistNode{
  // å¤´èŠ‚ç‚¹ã€å°¾èŠ‚ç‚¹
   zskiplistNode *header, *tail;
   // èŠ‚ç‚¹æ•°é‡
   long length;
   // å±‚çº§
   int level;
}
```

ä»ç»“æ„å®šä¹‰å¯ä»¥çœ‹å‡ºï¼Œä¸ç»å…¸è·³è·ƒè¡¨çš„å·®å¼‚ã€‚

1. æ–°å¢äº† backwardï¼Œæ”¯æŒåŒå‘æŒ‡é’ˆ
2. Levelæ–°å¢äº†spanï¼Œè·¨åº¦ï¼Œæ–¹ä¾¿è®¡ç®—æ’åã€‚

redisçš„è·³è·ƒè¡¨çš„ä¼˜åŒ–

1. ç»å…¸è·³è¡¨ä¸æ”¯æŒé‡å¤å€¼ï¼Œredisè·³è¡¨æ”¯æŒé‡å¤çš„åˆ†å€¼score
2. redisè·³è¡¨çš„æ’åºæ˜¯æ ¹æ®scoreå’Œæˆå‘˜å¯¹è±¡ä¸¤è€…å…±åŒå†³å®šçš„ã€‚zsetè¿˜ç»´æŠ¤äº†ä¸€ä¸ªmapï¼Œä¿å­˜æˆå‘˜å¯¹è±¡ä¸åˆ†å€¼çš„æ˜ å°„å…³ç³»ï¼Œè¢«ç”¨æ¥é€šè¿‡æˆå‘˜å¯¹è±¡å¿«é€ŸæŸ¥æ‰¾åˆ†å€¼ï¼Œå®šä½å¯¹åº”çš„èŠ‚ç‚¹ï¼Œåœ¨ZRANKã€ZREVRANKã€ZSCOREç­‰å‘½ä»¤ä¸­å‡æœ‰ä½¿ç”¨ã€‚
3. redisè·³è¡¨çš„åŸé“¾è¡¨æ˜¯ä¸ªåŒå‘é“¾

#### zsetä¸­çš„dict

zsetè¿˜ç»´æŠ¤äº†ä¸€ä¸ªmapï¼Œä¿å­˜æˆå‘˜å¯¹è±¡ä¸åˆ†å€¼çš„æ˜ å°„å…³ç³»ï¼Œè¢«ç”¨æ¥é€šè¿‡æˆå‘˜å¯¹è±¡å¿«é€ŸæŸ¥æ‰¾åˆ†å€¼ï¼Œå®šä½å¯¹åº”çš„èŠ‚ç‚¹ï¼Œåœ¨ZRANKã€ZREVRANKã€ZSCOREç­‰å‘½ä»¤ä¸­å‡æœ‰ä½¿ç”¨ã€‚  
å¦å¤–ï¼Œè¿™ä¸ªmapè¿˜ç”¨äºæ’å…¥èŠ‚ç‚¹æ—¶ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨é‡å¤çš„æˆå‘˜å¯¹è±¡ã€‚è§ä¸‹é¢redisæºç ä¸­çš„dictFindå‡½æ•°ã€‚

```c++
intÂ zsetAdd(robjÂ *zobj,Â doubleÂ score,Â sdsÂ ele,Â intÂ in_flags,Â intÂ *out_flags,Â doubleÂ *newscore)Â {  
Â Â Â Â //Â ...  
Â Â Â Â /*Â UpdateÂ theÂ sortedÂ setÂ accordingÂ toÂ itsÂ encoding.Â */  
Â Â Â Â ifÂ (zobj->encodingÂ ==Â OBJ_ENCODING_ZIPLIST)Â {  
Â Â Â Â Â Â Â Â //Â ...  
Â Â Â Â }Â elseÂ ifÂ (zobj->encodingÂ ==Â OBJ_ENCODING_SKIPLIST)Â {  
Â Â Â Â Â Â Â Â zsetÂ *zsÂ =Â zobj->ptr;  
Â Â Â Â Â Â Â Â zskiplistNodeÂ *znode;  
Â Â Â Â Â Â Â Â dictEntryÂ *de;  
  
Â Â Â Â Â Â Â Â deÂ =Â dictFind(zs->dict,ele);  
Â Â Â Â Â Â Â Â ifÂ (deÂ !=Â NULL)Â {  
Â Â Â Â Â Â Â Â Â Â Â Â //Â å·²ç»å­˜åœ¨  
Â Â Â Â Â Â Â Â Â Â Â Â //Â ...  
Â Â Â Â Â Â Â Â }Â elseÂ ifÂ (!xx)Â {  
Â Â Â Â Â Â Â Â Â Â Â Â //Â ä¸å­˜åœ¨ï¼Œæ’å…¥  
Â Â Â Â Â Â Â Â Â Â Â Â eleÂ =Â sdsdup(ele);  
Â Â Â Â Â Â Â Â Â Â Â Â znodeÂ =Â zslInsert(zs->zsl,score,ele);  
Â Â Â Â Â Â Â Â Â Â Â Â serverAssert(dictAdd(zs->dict,ele,&znode->score)Â ==Â DICT_OK);  
Â Â Â Â Â Â Â Â Â Â Â Â *out_flagsÂ |=Â ZADD_OUT_ADDED;  
Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (newscore)Â *newscoreÂ =Â score;  
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ 1;  
Â Â Â Â Â Â Â Â }Â elseÂ {  
Â Â Â Â Â Â Â Â Â Â Â Â *out_flagsÂ |=Â ZADD_OUT_NOP;  
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ 1;  
Â Â Â Â Â Â Â Â }  
Â Â Â Â }  
}
```

## èµ„æ–™

[Tree Indexes - open-courses](https://zhenghe.gitbook.io/open-courses/cmu-15-445-645-database-systems/tree-indexes)  
[å¸¦ä½ å½»åº•å‡»æºƒè·³è¡¨åŸç†åŠå…¶Golangå®ç°ï¼ï¼ˆå†…å«å›¾è§£ï¼‰-è½»è¯†](https://www.qinglite.cn/doc/4474647751d7ac14c)  
[golangæ³›å‹å®ç°â€”â€”skiplist-åŸåˆ›æ‰‹è®°-æ…•è¯¾ç½‘](https://m.imooc.com/article/details?article_id=326304)  
[æ·±å…¥ç†è§£Redisè·³è·ƒè¡¨çš„åŸºæœ¬å®ç°å’Œç‰¹æ€§ - æ˜é‡‘](https://juejin.cn/post/6893072817206591496)
