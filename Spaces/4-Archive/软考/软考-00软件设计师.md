---
title: 计算机组成与结构
date created: 2022-03-21
date modified: 2023-01-20
---

# 计算机组成与结构

## 计算机系统知识

### 计算机硬件组成

+ 运算器
+ 控制器
+ 存储器 (内部存储器（内存，容量小，速度快） 和外部存储器 (硬盘、光盘。容量大，速度慢))
+ 输入设备(鼠标、键盘)
+ 输出设备(显示器)

## 中英处理单元（CPU）

### cpu如何执行程序？

 1. cpu如何区分 0110 是地址还是数据还是指令？  
看数据从哪里来，总线可分为3种类型  
地址总线: 说明是地址  
数据总线：说明是数据  
控制总线: 说明是控制信号。比如控制是读还是写操作等。

2. 主存储器与cpu如何交互？  
注意: MDR 是双向的。也就是可以读写。MAR是单向的

![](http://image.clickear.top/20220321102742.png)

### 指令周期

原则:

+ 指令 = 操作码 + 操作数
+ 通过MAR --> 地址总线，来定位地址
+ 通过控制总线， --> 传输读/写信号
+ 通过MDR --> 数据总线 --> 主存 。进行数据交互
+ 1. PC （保存指令地址） --> MAR --> 地址总线 --> 定位到地址
+ 2. 控制信息，发送读信号。 主存 --> 数据总线 --> MDR --> IR(存放指令)
+ 3. CU发出指令 --> PC内容 +1

指令译码器，解析操作码。

#### 取指周期 (取指令)

![](http://image.clickear.top/20220321102203.png)

#### 间址周期(取操作数的有效地址)

![](http://image.clickear.top/20220321104444.png)

![](http://image.clickear.top/20220321110526.png)

#### 执行周期（取操作数）

#### 中断周期(为了保程序断点)

cpu(运算器 + 控制器 + 寄存器组 + 内部总线)

cpu功能: 实现 程序控制、操作控制、时间控制、数据处理功能

### 运算器:

功能:  
执行所有的算术运算、加减乘除。执行位运算

#### 算术逻辑单元 ALU

实现对数据的算术和逻辑运算

#### 累积寄存器AC:

运算结果或源操作数的存放区

#### 数据缓存寄存器(DR)

暂时存放内存的指令或数据

#### 状态条件寄存器

保存指令结果的条件吗内容，如溢出标志

### 控制器⭐

功能:  
程序控制、时序控制

#### 指令寄存器IR:

暂存CPU执行指令

#### 程序计数器PC:

存放指令执行地址

#### 地址寄存器AR:

保存当前CPU所访问的内存地址

#### 指令译码器ID:

分析指令操作码等组成

## 寻址方式 ⭐

![](http://image.clickear.top/20220321101819.png)

直接寻址 --> [500] = 800  
立即寻址 --> 500  
间接寻址 --> [ [500]] = [800] =300  
相对寻址 --> [500 + 2 + 200] = [702] = 325  
变址寻址 --> [ XR + 500 ] = [600] = 900  
寄存器寻址 --> 400  
寄存器间接寻址 --> [ 400 ] = 700

## 数据表示

在计算机中的表示，在计算机中，都是二进制

## 数的编码方式

+ 补码和移码，0是一样的。所以可以表示的数多一位。但是这多的一位，其实是负数的没太大意义。
+ 补码的补码 = 原码

原码： +0 和 -0;  
反码: 正数的反码 = 原码 。 负数的原码: 除符号位外，其它各位按位取反。  
+0 (0 0000000); -0(1 1111111)  
补码: 正数的补码 = 原码。 负数的补码 在原码基础上，除符号位外，其它各位按位取反，而后末位 +1; +0 = -0 = (00000000)  
移码: 用作浮点运算。无论正负数，都是将该原码的补码的首位(符号位)取反得到移码。

### 数的范围:

+ 为什么补码负数会多一位？因为补码没有区分 +0 和 -0。也就是说 1000，0000 这个码不用就浪费了。
+ 符合规定值。将该负数取绝对值,再用二进制表示出这个绝对值 (不管符号位！）对该二进制数进行取反加一操作就得到负数的补码了 （也就是求补操作!）
	+ 为128的二进制表示为:1000 0000
	+ 取反 0111 1111
	+ 加1 1000 0000  
这就是-128的补码  
这种办法算出的结果符合“规定值”.  
![[Pasted image 20220321143157.png]]

## 浮点数的标识 ⭐

浮点数: N= F * 2^E; E 是阶码， F称为尾数。  
数值<font color=#ff0000>范围</font>由<font color=#ff0000>阶码</font>确定，数值的<font color=#ff0000>精度</font>是由<font color=#ff0000>尾数</font>确定

规格化 尾数  
1.0 负数 0.1xxxx 正数

浮点数运算:

1. <font color=#ff0000>对阶</font>，小阶向大阶看起。尾数较少。尾数右移几位。
2. 尾数计算(相加，若是减运算，则加负数)
3. 结果规格化(即尾数表示规格化)

## 算术运算和逻辑运算(运算器的作用)

算术运算: 加减乘除  
逻辑运算: & | 异或 非 <<左移 >> 右移。 会舍弃

## 校验码

码距: 在2个编码中，从A码到B码所需要改变的位数。如 A:00 变成B: 11。码距为2.<font color=#ff0000>一般码距越大，越有利于纠错和检测</font>。

### 奇偶校验

+ 奇偶校验 (只能检错，不能纠错。可以检出<font color=#ff0000>1</font>位): 在编码中，增加1位校验位来使编码中1的个数为奇数、或偶数。只能检<font color=#ff0000>1</font>位错。  
为了使得1的个数是奇数或者偶数。

### 循环冗余校验码 (CRC)

+ 循环冗余校验码 (CRC，只能检错，不能纠错。可以检出<font color=#ff0000>多</font>位)。  
![[Pasted image 20220321160040.png]]

### 海明校验码(利用奇偶性来检查和纠错, ) ⭐

[《汉明码（海明码）》通俗易懂_苏某的橡皮擦的博客-CSDN博客](https://blog.csdn.net/weixin_61985100/article/details/123300540)

2<sup>k</sup> -1 >= n+k。 其中k为校验码的位数，k为信息的位数。  
怎么理解这个公式？ 首先，校验码可以指示出哪些有问题，即2<sup>k</sup>.那为什么要减-1呢？因为0代表的是没有错误。所以除0外，才是校验码能表示的数字。比如校验码为3位，我们可以认为000，是无错误。 001 是第一位出错等。  
那么很好理解，这个公式了。

原理:  
![[Pasted image 20220321175757.png]]  
—：1，2，3，4  
二：6，2，5，4  
三：6，7，3，4  
要记住只能错一个数字的情况哇，（下面会讲为啥是纠正一个错误，检查出两个错误的）  
那么我们来看几种情况：  
（1）如果第一组错误了，而第二第三组没有错误，是不是就排除了第二第三组的2，3，4，5，6，7了呢。所以错误是不是就是确定是1区域错了。  
（2）如果第一第二组错了，而第三组没有错，看上图，只有一个是错误的话那就是结果2了。  
（3）同理三组都错，是不是就确定了是4区域错了  
这里，只是举例检错原理

## 计算机体系结构

## 计算机体系分类

flynn分类  
指令流、数据流来进行分类。

指令流， 控制部分。 多个指导  
数据流， 处理器。 处理事情  
主存模块，只有有多就是多。

## 计算机指令

计算机指令组成: 操作码和操作数组成。

取指令--> 分析指令 --> 执行指令

|                | RISC                           | CISC                              |
| -------------- | ------------------------------ | --------------------------------- |
| 指令种类       | 少，精简                       | 多，丰富                          |
| 指令复杂度     | 低，简单                       | 高，复杂                          |
| 指令长度       | 固定                           | 变化                              |
| 寻址方式       | 少                             | 多                                |
| 实现译码方式   | 硬布线控制逻辑(组合逻辑控制器) | 微程序控制技术                    |
| 通用寄存器数量 | 多，大量                       | 少                                |
| 流水线技术     | 支持                           | <font color=#ff0000>不支持</font> |

## 指令流水线 ⭐

+ 流水线周期: 指令分成不同阶段，<font color=#ff0000>执行时间最长的段位流水线周期</font>
+ 流水线执行时间: <font color=#ff0000>1条指令总执行时间 + (总指令条数-1) * 流水线周期</font>
+ 执行n条指令的吞吐率 = n/流水线执行时间
+ 单位时间的流水线吞吐率 = 1/流水线周期
+ 加速比= 不使用流水线时间/ 使用流水线时间

## 存储系统

![[Pasted image 20220322113546.png]]  
存储容量、成本和速度的矛盾问题。  
cpu --> 通用寄存器 --> cache --> 主存 --> 磁盘

半导体:  
动态存储器(周期刷， 可随机访问， 主存是动态构成的)  
静态存储器(顺序访问 , cache是sam构成的)

相联存储器，是按内容访问的存储器。  
虚拟存储器，是主存和辅存组成的。

### 主存编址

![[Pasted image 20220322085728.png]]

### 局部性原理

时间局部性原理： 相邻的时间内会访问同一个数据项  
空间局部性原理: 相邻的空间地址会被连续访问

## 高速缓存cache(对程序员透明，由硬件自动完成映射)

地址映射：在cpu工作时，都是根据主存单位的地址。需要进行映射，是由<font color=#ff0000>硬件自动完成映射</font>。

+ 直接映射: 冲突最大
+ 全相连映射: 冲突最小
+ 组组相连映射: 冲突中等

## cachae命令率

2^10 = 1024

## 总线结构

![[Pasted image 20220322112405.png]]

### 概念

从广义上讲，任何连续两个以上电子元器件的导线都可以称为总线。通常分为以下三类

1. 内部总线: 内部芯片级别的总线，芯片与处理器直接的通信总线
2. 系统总线: 是板级总线。用于计算机内各部分之间的连接。 具体可分为
	1. 数据总线(并行数据传输位数)
	2. 地址总线(系统可管理的内存空间的大小)
	3. 控制总线(传输控制命令)
	4. 代表的有ISA总线，EISA总线，PCI总线
3. 外部总线: 设备一级的总线，微机和外部设备的总线。代表的有 RS232总线(串行总线)、SCSI（并行总线）、USB(通用串行总线)  
数据总线: 地址总线的宽度与数据字长一致。  
地址总线: 2<sup>32</sup> 代表4gb的内存。  
控制总线

#### 串并行总线

串行: 低速、长距离(串行，只能一个个走，慢。但是能长距离)  
并行: 高速、短距离

半双工: 同一时刻只能一个方向传输  
全双工: 同一时刻，可以双向传输

## 系统可靠性分析 ⭐

![[Pasted image 20220322112909.png]]

## 中断

1. 中断向量表，提供中断服务程序入口地址。
2. 中断响应时间: 中断请求开始，进入中断服务程序程序
3. 保护现场，返回来执行原程序。
4. 多级中断嵌套，使用堆栈来保护断点和现场最有效。
5. 中断是来自处理器外部的请求事件，异常是指令执行过程中在处理器内部发送的特殊事件。

## 输入输出（IO）控制方式

### 程序查询方式(轮询)

1. <font color=#ff0000>CPU和IO只能串行工作</font>。cpu需要一直检查，利用率低。
2. 一次只能读/写一个字
3. 由CPU将数放入内存

### 中断驱动方式(中断)

1. I/O设备通过中断信号主动报告IO已完成
2. <font color=#ff0000>CPU和IO可并行工作</font>
3. cpu利用率得到提高
4. 由cpu将数据放入内存
5. 一次只能读/写一个字

### 直接存储方式(DMA)⭐

1. <font color=#ff0000>cpu和io可并行工作</font>
2. 仅在传送<font color=#ff0000>数据块</font>的<font color=#ff0000>开始和结束</font>时，才需要cpu干预
3. 由<font color=#ff0000>外设直接</font>将数据放入内存（主存）
4. 一次读写的单位是"块"，而不是字

## 网络安全

### 五大要素

假冒

+ 保密性(窃听，加密算法): 确保信息不暴露给未授权的实体。
+ 完整性(篡改, 摘要算法 --> 数字签名): 保证数据传输过程是正确无误的。防篡改
+ 可用性: 保证合法的用户能以合法的手段来访问数据。
+ 可控性: 控制授权范围内的信息流向。避免比如横向授权等情况
+ 不可抵赖性 (否认，数字签名): 信息数据参与者不能否认自己发送的数据。通过非对称加密的私钥来加密。即数字签名

### 安全威胁分类

+ 重发攻击arp，拦截请求的拷贝，重新发送。
+ 拒绝服务ddos，对信息或其他资源的合法访问被无条件阻止
+ 窃听，非法手段窃听
+ 业务流分析，
+ 信息泄露，信息被泄露给非授权实体
+ 破坏信息的完整性， 数据被非授权的进行增删
+ 非授权访问，
+ 假冒，
+ 旁路控制，通过攻击手段，获取非授权的权利或特权
+ 授权侵犯(内部攻击),

### 加密技术-保密性(解决窃听问题)

#### 对称加密技术，(共享密钥，私钥，不公开密钥)

这里的不公开，是指只有接收人和发送人能知道密钥。  
对数据的加密和解密的密钥是相同的。

+ 安全性不高，只有一个密钥
+ 分发困难
+ 加密速度快。
+ 常用 DES(56位密钥,64位数据块)、3DES(3重DES，2个密钥3次加密，, 2个56位)、AES（替代DES）、RC-5,IDEA（128密钥，64位数据块）

#### 非对称加密技术(公开公钥)

公钥加密 --> 私钥解密  
私钥加密 --> 公钥解密

+ 安全性高，但是加密速度慢
+ RSA: 512或1024位密钥。计算量大
+ ECC: 椭圆曲线算法
+ 背包算法、Rabin、D-H、DSA

### 信息摘要- 完整性(篡改)

信息摘要，单向性，只能由数据生成信息摘要信息。

算法:

+ MD5算法(128位)、SHA(安全散列算法，产生160位)

这样根据原始内容 + 摘要信息，就可以知道。这个原始内容有没被篡改。但是不能保证篡改后的内容和篡改后的摘要信息，一起修改的情况。这个要配合 数字签名进行使用。

### 数字签名- 不可抵赖性(不可否认)

如果保证发送人是合法的，即只要保证唯一识别发送人即可。可以使用非对称加密中。发送方进行私钥对摘要进行加密。因为公钥是公开的。接受者就可以用公钥去解密。这样就可以保证了。  
也就是说，数字签名，可以保证真实性、完整性、不可抵赖性

### 数字证书

发送方可能本身就是伪造的。  
数字证书的原理:

1. 每个发送方要先向CA申请数字证书。数字证书是经过CA数字签名的。即CA使用私钥加密。CA的公钥，一般内置在操作系统中。接收方根据因为用CA公钥的解密，验证了CA的准确性。

本质上是 本地操作系统有CA的公钥，从网站下载的证书，能发现是CA颁发的，即可以说明数字证书中的某个网站的公钥是合法的。然后就可以用这个公钥进行加密数据。  
[[https]]

![](http://image.clickear.top/20220322134550.png)

### PKI公钥基础设施

提供公钥加密和数字签名服务的系统或平台

[[软考-01程序设计语言基础知识]]
